\chapter{Conclusion}

This section is the conclusion.  In this section the project is compared to its initial goals and its success is discussed.  Any challenges not discussed in previous sections are discussed.  Any problems that were unable to be solved during the stage of development are discussed.  Finally areas identified for future work are discussed in detail.

\section{Comparison to Objective}

\tdi{restate the objective}
\tdi{how met is the objective}

\section{Challenges Faced}

Some challenges were faced in this project that were not discussed elsewhere in this report.  These are below.

\subsection{wxPython Being Cross-Platform}
Python was chosen for this project to allow for the project to be run on any system.  A cross platform \ac{GUI} toolkit was chosen for the same reason.  wxPython was chosen (details of why can be found in the MPP report).  Initially this was successful.  The program was running on MacOS and Linux.  As the project was developed further some discrepancies were uncovered between wxPython on different platforms.  Initially this was coped with by writing different versions of parts of the code for each platform.  Eventually this became impractical.  Development support for Linux was halted.  Currently the project has only been tested running on MacOSX Mountain Lion.

An attempt was made to test the program on Windows, but there were problems installing the necessary Python libraries.

\section{Unsolved Problems}

\subsection{Complete Ordering Across Clients}

An initial version of the collaboration used blocking communication.  In a blocking mode it was possible to globally order the events.  This is described in Section~\ref{sec:collaboration}.  Blocking collaboration is far from optimal.  A slow network would make the collaboration unusable.  The program would be locked out from the user for the duration of the message and response.  Non blocking communication was added later through the use of threads when sending messages.  This had the undesirable side effect of not being able to guarantee correct ordering.

\tdi{Distributed Undo}

When doing a visualisation without any collaborators the undo and redo functionality works as expected.  In the collaborative mode however there are some flaws.  If we have the user and the collaborator, changes the user makes are sent to the collaborator.  If the user issues an undo command their undo history is correct.  The collaborator's undo history appears to forget states.  This leaves the collaborator and the user seeing different visualisations.  This bug appears to be related to the issues had when first implementing undo and redo when Python's deep copy had to be introduced.  Despite numerous attempts to solve this bug a solution was unable to be find before the project deadline.

\subsection{Matplotlib is Slow}

matplotlib is the de facto standard for graphing in Python this, amongst other reasons (detailed in MPP report), led to it being chosen for the graph visualisations in the project.  When features such as plotting the intensity of the gradient were added matplotlib was pushed to its limits.  It was discovered that matplotlib is not optimised for speed, it is instead optimised for producing publication standard graphics.  This poses a dilemma.  Researchers want to be able to generate quality graphs, whilst one of the purposes of the tool is allowing real time interactivity and customisation.  There are tweaks that can be applied to make matplotlib be faster, or there are alternative graphing libraries that could be considered.  Threading was also looked into but caused segmentation faults.

\section{The Future}

By the end of the project the program that had been developed was a in a state that could be used by users.  There is more functionality than the Eclipse plugin and it is stable.  There is, however, work to be done if development were to continue.  This is detailed below:

\subsection{Plots as Queries}
A prototype system for using plots as queries was developed (Section~\ref{sec:search}).  Early results were promising.~\tdi{Were they?}.  These results are not definite by any means.  Further work needs to be performed.  The first step would be working with a team of Biologists and creating a large evaluation set.  This will allow the effectiveness to be accurately measured.  This would also include tuning of the parameters used.  Other systems for using time series data as queries could also be developed and then the different systems can have their effectiveness compared.

The next step would be a single online repository of time series data that was been processed to be suitable for searching.  This would be done with the technique in Section~\ref{sec:search}.  Having a single online repository has two main benefits.  One: Tf.idf, information retrieval and machine learning in general all rely on having a large amount of data.  One user will typically not have enough data to be of much use if they want to use plots as a query against their own data.  Data that is not the user's would be used for the statistics but does not have to be made available to other users, however hopefully most researchers would agree to allow their data to be accessible to others.  The second benefit is that having a central repository takes it out of the hands of the user.  Part of the reason for not integrating this feature with the \ac{UI} during this project is that it would have been difficult to guarantee to keep track of the experiment data relating to the time series data in the database.  If the data had been uploaded to a central repository then there would be no problems tracking it.

\subsection{More Data Mining and Machine Learning}

Enabling search was an early step into what can be done with machine learning and data mining with time series data.  Other areas of interest include classification, clustering \& anomaly detection.  All of these can be built on top of the work that was done in Section ~\ref{sec:search}.

These are all features that would allow the user to analyse their work in a more detailed manner.

Again, all of these works best with a large amount of data and so would need to be tied into an online repository.

\subsection{Put it in the Cloud}
\label{sec:cloud}
All of the collaboration software reviewed in Section~\ref{sec:review} worked on a model where the is a single server.  This is a much simpler model for collaboration as there is now no real distributed element to it.  Ordering is solved as the only order cared about is the ordering on the server.

This would require some refactoring of the project.  The code would need to be more separated into server and client.  The server would do the majority of the work: parsing the data, performing the intensity calculations and handling the creation of annotations.  We would then need to create a much more standalone client.  This should do very little actual processing.  It should just display the information from the server.

Work towards this goal would also hopefully include rewriting the project so that the client could be a browser based client.  A lot of problems were faced with wxPython not being as cross platform compatible as had been hoped.  Rewriting the client to be browser based should solve the cross platform problems.

The cloud backend would also, hopefully, include a repository for storing the attached files.  Currently there is no way for attached files to be sent to a collaborator.  They were considered too large to be able to be sent through the implementation of collaboration described in Section~\ref{sec:collaboration}.  Without a central file repository we would some other way of sending files.  This comes close to violating both Lett's and Zawinski's laws~\cite{atwoord}.  These laws state, respectively, the all software evolves until it can send email and that all software evolves until it can read email.  They are a sign of feature creep in software.  Email would have been a potential solution on how to transfer the files between users.  A central file repository avoids the need for feature creep.  Previews of the files, title and thumbnail, could be part of the real time features.  The collaborators can upload and download files as necessary.

\subsection{Improve the architecture}

In Section~\ref{sec:architecture} the initial lack of architecture is discussed.  The architecture was improved and now resembles a \ac{MVC} architecture.  This work on the architecture should be continued in the future.  Making the architecture fully \ac{MVC} would greatly enable the work towards moving the tool to the cloud (Section~\ref{sec:cloud}).

Having a \ac{MVC} architecture would also make it much easier to change interfaces.  As trends change new platforms could easily by developed for as all that would be needed would be a new client to interact with the server.  There is a trend at the moment towards mobile applications.  A tablet version of the tool could be useful to users.  With the architectural changes a tablet version would be possible.

\subsection{More customization}
The user is given control over the appearance of lines on the graph.  This could be expanded further into the tool.  Currently annotations cannot be customized, they can only be black.  More annotation options could be offered.  As discussed in Section~\ref{sec:normalised}, different normalisation methods could be included.

\subsection{Real World Studies}
More in depth evaluations should be performed.  An ethnographic study should be the goal.  As discussed in Section~\ref{sec:evaluation} the evaluation techniques used could only provide so much information.  An ethnographic study would bring to light truly how fit for purpose the tool is.
\tdi{could this go in the evaluation}

\subsection{Change how the visualisation is calculated}
Currently the visualisation is stored as a snapshot of the entire state.  The undo functionality is built around taking copies of this snapshot. When the visualisations are being displayed the \ac{UI} components look at this single snapshot.  Making copies of a large snapshot is not a cheap operation.  A more efficient approach would be to store operations.  To draw the latest visualisation the tool would simply traverse this list from the start.  Undoing an action would simply then be removing the last operation.

\subsection{More collaboration}
In addition to changing the model of collaboration from being distributed to centralised, further work should be done towards enabling communication between users.  Currently collaborators will have to use a phone or an external chat client to discuss the work.  A chat client could be integrated into the program, allowing the collaborate to discuss without having to also run a secondary program.  This chat client could also then be specialised to include features that would be relevant to visualising data.

\section{Final Remarks}

\tdi{think up some final remarks}
